<?php

/*
 *
 *  _____                       _
 * /  ___|                     | |
 * \ `--. _   _ _ __ ___  _ __ | |_   _
 *  `--. \ | | | '_ ` _ \| '_ \| | | | |
 * /\__/ / |_| | | | | | | |_) | | |_| |
 * \____/ \__, |_| |_| |_| .__/|_|\__, |
 *         __/ |         | |       __/ |
 *        |___/          |_|      |___/
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author Symply Team
 * @link http://www.symplymc.com/
 *
 *
 */

declare(strict_types=1);

namespace symply\behavior\block;

use Generator;
use pocketmine\data\bedrock\block\convert\BlockStateReader;
use pocketmine\data\bedrock\block\convert\BlockStateWriter;
use pocketmine\nbt\NBT;
use pocketmine\nbt\tag\CompoundTag;
use pocketmine\nbt\tag\ListTag;
use pocketmine\network\mcpe\convert\BlockStateDictionaryEntry;
use symply\behavior\block\permutation\BlockPermutation;
use symply\behavior\block\property\BlockProperty;
use symply\utils\Utils;
use function array_map;
use function array_merge;
use function array_reverse;
use function in_array;

abstract class Permutation extends BlockCustom
{
	/** @var BlockProperty[] */
	private array $properties = [];

	/** @var BlockPermutation[] */
	private array $permutations = [];

	/**
	 * @return BlockProperty[]
	 */
	public function getProperties() : array
	{
		return $this->properties;
	}

	public function addProperty(BlockProperty $property) : self
	{
		if (in_array($property, $this->properties, true)){
			return $this;
		}
		$this->properties[] = $property;
		$this->permutations = array_merge($this->permutations, $property->getPermutations());
		return $this;
	}

	abstract public function deserializeState(BlockStateReader $reader) : void;
	abstract public function serializeState(BlockStateWriter $writer) : void;

	/**
	 * @param BlockProperty[] $properties
	 */
	public function setProperties(array $properties) : self
	{
		$this->properties = $properties;
		$this->permutations = [];
		foreach ($this->properties as $property) {
			$this->permutations = array_merge($this->permutations, $property->getPermutations());
		}
		return $this;
	}

	private function getPermutations() : array
	{
		return $this->permutations;
	}

	public function getComponentsTag() : CompoundTag
	{
		return parent::getComponentsTag()->setTag("minecraft:on_player_placing", CompoundTag::create());
	}

	public function getPropertiesTag() : CompoundTag
	{
		return parent::getPropertiesTag()
			->setTag("permutations", new ListTag(array_map(fn(BlockPermutation $permutation) => $permutation->toNBT(), $this->getPermutations()), NBT::TAG_Compound))
			->setTag("properties", new ListTag(array_reverse(array_map(fn(BlockProperty $property) => $property->toNBT(), $this->getProperties())), NBT::TAG_Compound));// TODO: Change the autogenerated stub
	}

	public function toBlockStateDictionaryEntry() : Generator
	{
		$listPermutations = $this->getProperties();
		if (empty($permutations)) {
			return parent::toBlockStateDictionaryEntry();
		}
		$listBlockPropertyName = array_map(fn(BlockProperty $property) => $property->getName(), $listPermutations);
		foreach (Utils::getCartesianProduct(array_map(fn(BlockProperty $property) => $property->getValues(), $listPermutations)) as $meta => $permutations) {
			$states = [];
			foreach ($permutations as $i => $value) {
				$states[$listBlockPropertyName[$i]] = Utils::getTagType($value);
			}
			yield new BlockStateDictionaryEntry($this->getIdInfo()->getNamespaceId(), $states, $meta);
		}
	}
}
